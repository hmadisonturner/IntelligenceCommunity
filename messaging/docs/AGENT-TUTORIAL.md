# Building Your First Agent

## ğŸ¤– What is an Agent?

In our messaging system, an **agent** is simply any entity that connects to the message broker. This includes:

- ğŸ‘¤ **Human users** interacting through a web browser
- ğŸ¤– **Automated scripts** that post or respond to messages
- ğŸ“Š **Data sources** that periodically publish information
- ğŸ”” **Notification systems** that alert about events

The power of this approach is in its simplicity: **agents are just clients of our messaging system**.

---

## ğŸ”Œ Agent Connection Basics

All agents use the same protocol to communicate:

1. Connect to the WebSocket server
2. Receive an identity from the broker
3. Subscribe to relevant channels
4. Send and receive messages

This shared foundation means humans and automated systems can seamlessly interact.

---

## ğŸš€ Building a Simple Reporting Agent

Let's create a simple "ReportBot" that generates a daily sales report and posts it to a channel.

### Prerequisites:

- Python 3.7+ installed
- `websockets` library (`pip install websockets`)
- Our messaging server running locally

### Step 1: Import Required Libraries

```python
import asyncio
import websockets
import json
import random
from datetime import datetime
```

### Step 2: Define Agent Configuration

```python
# Agent configuration
BROKER_URL = "ws://localhost:8765"
REPORT_CHANNEL = "daily-reports"
AGENT_NAME = "ReportBot"  # Note: Server will assign actual identity
```

### Step 3: Create Sample Data Generation

```python
def generate_sales_report():
    """Generate a simple mock sales report with random data."""
    departments = ["Electronics", "Clothing", "Food", "Books"]
    
    report = {
        "date": datetime.now().strftime("%Y-%m-%d"),
        "total_sales": random.randint(5000, 20000),
        "departments": {}
    }
    
    # Generate department data
    for dept in departments:
        report["departments"][dept] = {
            "sales": random.randint(500, 5000),
            "transactions": random.randint(10, 100)
        }
    
    return report
```

### Step 4: Define Agent Communication Logic

```python
async def report_agent():
    """Main agent logic."""
    
    # Connect to broker
    async with websockets.connect(BROKER_URL) as ws:
        # Wait for identity from server
        identity_msg = await ws.recv()
        print(f"Received: {identity_msg}")
        
        # Should receive something like: IDENTITY:user-abc123
        if identity_msg.startswith("IDENTITY:"):
            agent_id = identity_msg.split(":")[1]
            print(f"Agent connected with ID: {agent_id}")
        
        # Wait for channel list
        channels_msg = await ws.recv()
        print(f"Available channels: {channels_msg}")
        
        # Subscribe to report channel
        await ws.send(f"SUBSCRIBE:{REPORT_CHANNEL}")
        subscribe_ack = await ws.recv()
        print(f"Subscription response: {subscribe_ack}")
        
        # Generate and send report
        report = generate_sales_report()
        formatted_report = json.dumps(report, indent=2)
        report_message = f"""
ğŸ“Š DAILY SALES REPORT: {report['date']}
ğŸ’° Total Sales: ${report['total_sales']}

Department Breakdown:
{'-' * 30}
"""
        
        # Add each department to the message
        for dept, data in report["departments"].items():
            report_message += f"â€¢ {dept}: ${data['sales']} ({data['transactions']} transactions)\n"
            
        report_message += f"\nGenerated by {AGENT_NAME} at {datetime.now().strftime('%H:%M:%S')}"
        
        # Send the report to the channel
        await ws.send(f"PUBLISH:{REPORT_CHANNEL}:{report_message}")
        print(f"Report published to {REPORT_CHANNEL}")
        
        # Wait for message confirmation and then exit
        response = await ws.recv()
        print(f"Server response: {response}")

# Run the agent
if __name__ == "__main__":
    asyncio.run(report_agent())
```

### Step 5: Run Your Agent

Save the code as `report_agent.py` and run it:

```bash
python report_agent.py
```

When executed, the agent will:
1. Connect to the message broker
2. Subscribe to the "daily-reports" channel
3. Generate a sales report with random data
4. Format and post it to the channel
5. Disconnect after confirmation

---

## ğŸ’¡ Key Agent Concepts

### 1. Identity Management

The broker assigns identities to all agents:
```python
identity_msg = await ws.recv()  # Receive IDENTITY:user-abc123
agent_id = identity_msg.split(":")[1]
```

### 2. Channel Subscription

Agents subscribe to relevant channels to post or receive messages:
```python
await ws.send(f"SUBSCRIBE:{REPORT_CHANNEL}")
```

### 3. Message Publishing

Agents format and publish messages to channels:
```python
await ws.send(f"PUBLISH:{REPORT_CHANNEL}:{report_message}")
```

### 4. Event-Driven Architecture

Agents can react to specific messages by listening to channels:
```python
# Example: Process messages (not included in the simple agent)
async for message in ws:
    if message.startswith("MSG:"):
        # Parse and process the message
        pass
```

---

## ğŸ”„ Human-Agent Interaction

With our agent running, human users can:

- Subscribe to the "daily-reports" channel in their browser client
- See reports as they are posted
- Reply to reports in the same channel
- Mention the bot specifically if needed

This is the power of our unified messaging system - humans and automated agents use the same channels and protocols to communicate seamlessly.

---

## ğŸš€ Next Steps

After mastering the basics, you can enhance your agent with:

1. **Event listening** - Have your agent respond to specific messages
2. **Data sources** - Connect to databases or APIs for real data
3. **Scheduled reporting** - Use cron jobs to run your agent at set times
4. **Interactive behavior** - Make your agent respond to commands

---

## ğŸ” Common Patterns

### Scheduled Reporting Agent

```python
# Use with cron or other scheduler to run daily
python report_agent.py
```

### Query-Response Agent

```python
# Pseudocode for an agent that responds to queries
async for message in websocket:
    if message.startswith("MSG:") and "query" in message:
        # Process the query
        result = process_query(message)
        # Send back the result
        await ws.send(f"PUBLISH:{channel}:{result}")
```

Remember: in our system, agents are just specialized clients of the messaging platform, whether they're automated or human!